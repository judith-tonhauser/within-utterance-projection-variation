group_by(qud) %>%
summarize(Mean = mean(responseMC), CILow = ci.low(responseMC), CIHigh = ci.high(responseMC)) %>%
mutate(YMin = Mean - CILow, YMax = Mean + CIHigh) %>%
select(-c(CILow, CIHigh)) %>%
mutate(qud = recode(qud, "ai" = "CC? QUD", "nai" = "BEL? QUD")) %>%
mutate(content = "BEL")
means.BEL.utt.qud
# bind the data
means.by.qud = rbind(means.C.utt.qud,means.BEL.utt.qud)
means.by.qud
# plot
ggplot() +
geom_bar(data=PL2,aes(x=content, y=prob),stat = "identity",width = 0.3,position = position_nudge(x = -.15)) +
geom_bar(data=means.by.qud,aes(x=content, y=Mean), stat = "identity",width = 0.3, alpha = .7,position = position_nudge(x = .15)) +
geom_errorbar(data=means.by.qud,aes(x=content, ymin=YMin, ymax=YMax), width=0.2, colour="black", alpha=1, linewidth=.5,position = position_nudge(x = .15)) +
theme(legend.position="top") +
theme(axis.text.y = element_text(size=10)) +
facet_grid(. ~ qud) +
ylab("Predicted probability (black) \n Mean inference rating (gray)") +
xlab("Inferences") +
scale_y_continuous(limits = c(-.1,1.1),breaks = c(0,0.2,0.4,0.6,0.8,1.0), labels = c("0",".2",".4",".6",".8","1"))
ggsave("graphs/Fig4-comparison-neg-know.pdf",height=2.5,width=3.5)
# read model data
PL = read_csv("data/PL.csv")
nrow(PL) #24
# make long format to be able to aggregate state.CC and state.BEL
PL2 = PL %>% pivot_longer(
cols = state.CC:state.BEL,
names_to = c("state"),
values_to = c("trueFalse"))
PL2
nrow(PL2) #48
# now keep rows where state.BEL=1 or state.CC=1
PL2 = PL2 %>%
filter(trueFalse == 1) %>%
filter(utterance == "neg-know-pos-dance") %>%
mutate(utterance = recode(utterance, "neg-know-pos-dance" = "neg-know")) %>%
droplevels() %>%
rename("qud" = "qudBias") %>%
mutate(state = recode(state, "state.BEL" = "BEL", "state.CC" = "CC")) %>%
mutate(qud = recode(qud, "BEL?" = "BEL? QUD", "CC?" = "CC? QUD"))
PL2
# plot
ggplot(data=PL2, aes(x=state, y=prob)) +
geom_bar(stat = "identity",width = 0.3) +
theme(legend.position="top") +
theme(axis.text.y = element_text(size=10)) +
facet_wrap(. ~ qud) +
#theme(axis.title.x=element_blank()) +
ylab("Predicted probability") +
xlab("Inferences") +
scale_y_continuous(limits = c(-.1,1.1),breaks = c(0,0.2,0.4,0.6,0.8,1.0), labels = c("0",".2",".4",".6",".8","1"))
# plot
ggplot(data=PL2, aes(x=state, y=prob)) +
geom_bar(stat = "identity",width = 0.3) +
theme(legend.position="top") +
theme(axis.text.y = element_text(size=10)) +
facet_wrap(. ~ qud) +
#theme(axis.title.x=element_blank()) +
ylab("Predicted probability") +
xlab("Inferences") +
scale_y_continuous(limits = c(-.1,1.1),breaks = c(0,0.2,0.4,0.6,0.8,1.0), labels = c("0",".2",".4",".6",".8","1"))
ggsave("graphs/qualitativePredictions.pdf",height=2,width=3)
# read cleaned up speaker
S = read_csv(file="data/S.csv")
# BEL? QUD
S_agg = aggregate(prob~BEL*CC*state,data=S[S$qud == "BEL? QUD" & S$utterance == "neg-know",],FUN=mean)
S_agg
S_agg$PA = paste(S_agg$CC, S_agg$BEL, sep="-")
S_agg$combined = paste(S_agg$CC, S_agg$BEL, S_agg$state, sep="-")
S_agg
ggplot(S_agg, aes(x=prob, y = PA)) +
geom_bar(stat="identity") +
ylab("Private assumption") +
xlab("probability") +
facet_grid(state ~ .) +
#ggtitle("Observed state") +
scale_x_continuous(breaks = c(0,.02,.04),labels = c("0", ".02", ".04")) +
theme(plot.title = element_text(hjust = 0.5, size = 11))
ggplot(S_agg, aes(x=prob, y = PA)) +
geom_bar(stat="identity") +
ylab("Private assumption") +
xlab("probability") +
facet_grid(state ~ .) +
#ggtitle("Observed state") +
scale_x_continuous(breaks = c(0,.02,.04),labels = c("0", ".02", ".04")) +
theme(plot.title = element_text(hjust = 0.5, size = 11))
ggsave("graphs/Fig5a-neg-know-probability-by-PA-and-state-qudBEL.pdf",width=3,height=4)
# CC? QUD
S_agg = aggregate(prob~BEL*CC*state,data=S[S$qud == "CC? QUD" & S$utterance == "neg-know",],FUN=mean)
S_agg
S_agg$PA = paste(S_agg$CC, S_agg$BEL, sep="-")
S_agg$combined = paste(S_agg$BEL, S_agg$CC, S_agg$state, sep="-")
S_agg
ggplot(S_agg, aes(x=prob, y = PA)) +
geom_bar(stat="identity") +
ylab("Private assumption") +
xlab("probability") +
facet_grid(state ~ .) +
#ggtitle("Observed state") +
scale_x_continuous(breaks = c(0,.00002,.00004),labels = c("0", ".00002",".00004")) +
theme(plot.title = element_text(hjust = 0.5, size = 11))
ggplot(S_agg, aes(x=prob, y = PA)) +
geom_bar(stat="identity") +
ylab("Private assumption") +
xlab("probability") +
facet_grid(state ~ .) +
#ggtitle("Observed state") +
scale_x_continuous(breaks = c(0,.00002,.00004),labels = c("0", ".00002",".00004")) +
theme(plot.title = element_text(hjust = 0.5, size = 11))
ggsave("graphs/Fig5b-neg-know-probability-by-PA-and-state-qudCC.pdf",width=3,height=4)
# set working directory to directory of script
this.dir <- dirname(rstudioapi::getSourceEditorContext()$path)
setwd(this.dir)
# load required packages
library(tidyverse)
# color-blind-friendly palette
cbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
theme_set(theme_bw())
# load helper functions
source('../../helpers.R')
# load clean data
d = read_csv("../data/cd.csv")
nrow(d) #327
# load clean data
d = read_csv("../data/cd.csv")
nrow(d) #327
# identify mean ratings
means.C.utt.qud = d %>%
group_by(utterance,qud) %>%
summarize(Mean = mean(responseCC), CILow = ci.low(responseCC), CIHigh = ci.high(responseCC)) %>%
mutate(YMin = Mean - CILow, YMax = Mean + CIHigh) %>%
select(-c(CILow, CIHigh)) %>%
mutate(qud = recode(qud, "ai" = "CC?", "nai" = "BEL?")) %>%
mutate(content = "CC")
means.C.utt.qud
means.BEL.utt.qud = d %>%
group_by(utterance, qud) %>%
summarize(Mean = mean(responseMC), CILow = ci.low(responseMC), CIHigh = ci.high(responseMC)) %>%
mutate(YMin = Mean - CILow, YMax = Mean + CIHigh) %>%
select(-c(CILow, CIHigh)) %>%
mutate(qud = recode(qud, "ai" = "CC?", "nai" = "BEL?")) %>%
mutate(content = "BEL")
means.BEL.utt.qud
# bind the data
means.by.qud = rbind(means.C.utt.qud,means.BEL.utt.qud)
means.by.qud = means.by.qud %>%
mutate(utterance = recode(utterance, "think-neg" = "neg-think",
"think-pos" = "pos-think",
"know-neg" = "neg-know",
"know-pos" = "pos-know"))
means.by.qud
table(means.by.qud$utterance)
# transform the data to long
d = d %>%
gather(responseTo, rating, responseCC:responseMC) %>%
mutate(responseTo = recode(responseTo, "responseCC" = "CC", "responseMC" = "BEL")) %>%
mutate(qud = recode(qud, "ai" = "CC?", "nai" = "BEL?")) %>%
mutate(utterance = recode(utterance, "think-neg" = "neg-think",
"think-pos" = "pos-think",
"know-neg" = "neg-know",
"know-pos" = "pos-know"))
nrow(d) #654
# order the utterances by mean projection strength of CC
tmp = d %>%
filter(responseTo == "CC") %>%
group_by(utterance) %>%
summarize(Mean = mean(rating))
tmp
means.by.qud$utterance = factor(means.by.qud$utterance, levels = tmp$utterance[order(tmp$Mean)], ordered = TRUE)
d$utterance = factor(d$utterance, levels = tmp$utterance[order(tmp$Mean)], ordered = TRUE)
levels(means.by.qud$utterance)
str(means.by.qud$utterance)
levels(d$utterance)
str(d$utterance)
# library for nested facets
library(ggh4x)
ggplot(data=means.by.qud, aes(x=content, y=Mean)) +
geom_violin(data = d, aes(x = responseTo, y = rating), fill = "gray90") +
geom_point() +
geom_errorbar(aes(x=content, ymin=YMin, ymax=YMax), width=0.2, colour="black", alpha=1, size=.5) +
theme(legend.position="top") +
theme(axis.text.y = element_text(size=10)) +
facet_nested(. ~ utterance + qud) +
ylab("Mean inference rating") +
xlab("Inference") +
scale_y_continuous(limits = c(0,1),breaks = c(0,0.2,0.4,0.6,0.8,1.0), labels = c("0",".2",".4",".6",".8","1"))
ggsave("../graphs/mean-rating-by-utt-and-qud.pdf",height=3,width=8)
# set working directory to directory of script
this.dir <- dirname(rstudioapi::getSourceEditorContext()$path)
setwd(this.dir)
# load required packages
library(tidyverse)
library(lme4)
library(lmerTest)
library(forcats)
library(emmeans)
# load helper functions
source('../../helpers.R')
# load data
d = read_csv("../data/cd.csv")
nrow(d) #327
# transform the data
d = d %>%
gather(responseTo, rating, responseCC:responseMC) %>%
mutate(responseTo = recode(responseTo, "responseCC" = "CC", "responseMC" = "BEL")) %>%
mutate(qud = recode(qud, "ai" = "CC?", "nai" = "BEL?"))
nrow(d) #654
# set reference levels
proj = d %>%
filter(utterance == "know-neg") %>%
mutate(qud = fct_relevel(qud, "CC?"),
responseTo = fct_relevel(responseTo, "CC"))
nrow(proj) #152
# linear model
m = lmer(rating ~ responseTo*qud + (1|content), data=proj)
summary(m)
# pairwise comparison for each predictor while holding the other one constant
pairs(emmeans(m, ~ responseTo*qud), simple = "each")
# load data
d = read_csv("../data/cd.csv")
nrow(d) #327
# transform the data
d = d %>%
gather(responseTo, rating, responseCC:responseMC) %>%
mutate(responseTo = recode(responseTo, "responseCC" = "CC", "responseMC" = "BEL")) %>%
mutate(qud = recode(qud, "ai" = "CC?", "nai" = "BEL?"))
nrow(d) #654
# set reference levels
proj = d %>%
filter(utterance == "know-neg" | utterance == "think-neg") %>%
filter(responseTo == "BEL") %>%
mutate(qud = fct_relevel(qud, "CC?"),
utterance = fct_relevel(utterance, "think-neg"))
nrow(proj) #148
# linear model
m = lmer(rating ~ utterance*qud + (1|content), data=proj)
summary(m)
# linear model
m = lmer(rating ~ utterance*qud + (1|content), data=proj)
summary(m)
# set reference levels
proj = d %>%
filter(utterance == "know-neg" | utterance == "think-neg") %>%
filter(responseTo == "BEL") %>%
mutate(qud = fct_relevel(qud, "BEL?"),
utterance = fct_relevel(utterance, "think-neg"))
nrow(proj) #148
# linear model
m = lmer(rating ~ utterance*qud + (1|content), data=proj)
summary(m)
# load data
d = read_csv("../data/cd.csv")
nrow(d) #327
# transform the data
d = d %>%
gather(responseTo, rating, responseCC:responseMC) %>%
mutate(responseTo = recode(responseTo, "responseCC" = "CC", "responseMC" = "BEL")) %>%
mutate(qud = recode(qud, "ai" = "CC?", "nai" = "BEL?"))
nrow(d) #654
# set reference levels
proj = d %>%
filter(utterance == "know-neg" | utterance == "think-neg") %>%
filter(responseTo == "BEL") %>%
mutate(qud = fct_relevel(qud, "CC?"),
utterance = fct_relevel(utterance, "think-neg"))
nrow(proj) #148
# linear model
m = lmer(rating ~ utterance*qud + (1|content), data=proj)
summary(m)
# set reference levels
proj = d %>%
filter(utterance == "know-neg" | utterance == "think-neg") %>%
filter(responseTo == "BEL") %>%
mutate(qud = fct_relevel(qud, "BEL?"),
utterance = fct_relevel(utterance, "think-neg"))
nrow(proj) #148
# linear model
m = lmer(rating ~ utterance*qud + (1|content), data=proj)
summary(m)
# load datas
d = read_csv("../data/cd.csv")
nrow(d) #327
# transform the data
d = d %>%
gather(responseTo, rating, responseCC:responseMC) %>%
mutate(responseTo = recode(responseTo, "responseCC" = "CC", "responseMC" = "BEL")) %>%
mutate(qud = recode(qud, "ai" = "CC?", "nai" = "BEL?"))
nrow(d) #654
# set reference levels
proj = d %>%
filter(utterance == "know-neg") %>%
mutate(qud = fct_relevel(qud, "CC?"),
responseTo = fct_relevel(responseTo, "CC"))
nrow(proj) #152
# linear model
m = lmer(rating ~ responseTo*qud + (1|content), data=proj)
summary(m)
# pairwise comparison for each predictor while holding the other one constant
pairs(emmeans(m, ~ responseTo*qud), simple = "each")
# load data
d = read_csv("../data/cd.csv")
nrow(d) #327
# transform the data
d = d %>%
gather(responseTo, rating, responseCC:responseMC) %>%
mutate(responseTo = recode(responseTo, "responseCC" = "CC", "responseMC" = "BEL")) %>%
mutate(qud = recode(qud, "ai" = "CC?", "nai" = "BEL?"))
nrow(d) #654
# because rating assumes values of 0 and 1, which beta regression cannot handle, transform: (Smithson & Verkuilen 2006)
# y_new = (y_old * (n−1) + 0.5) / n (where n is the sample size)
# note: first rescaling of y'=(y-a)/(b-a) not necessary because highest and lowest value are 0 and 1 already
summary(t$rating)
# because rating assumes values of 0 and 1, which beta regression cannot handle, transform: (Smithson & Verkuilen 2006)
# y_new = (y_old * (n−1) + 0.5) / n (where n is the sample size)
# note: first rescaling of y'=(y-a)/(b-a) not necessary because highest and lowest value are 0 and 1 already
summary(d$rating)
d$betarating = (d$rating*(nrow(d)-1) + .5)/nrow(d)
summary(d$betarating)
# filter to relevant utterances and set reference levels
proj = d %>%
filter(utterance == "know-neg" | utterance == "think-neg") %>%
filter(responseTo == "BEL") %>%
mutate(qud = fct_relevel(qud, "CC?"),
utterance = fct_relevel(utterance, "think-neg"))
nrow(proj)
# fit the model
prior = get_prior(betarating ~ utterance*qud + (1|content),family = Beta(),data=proj)
prior
library(tidyverse)
library(tidybayes)
library(dplyr)
library(dichromat)
library(forcats)
library(ggrepel)
library(brms)
library(knitr)
library(tidyverse)
library(tidybayes)
library(dplyr)
library(dichromat)
library(forcats)
library(brms)
library(knitr)
library(emmeans)
# load data
d = read_csv("../data/cd.csv")
nrow(d) #327
# transform the data
d = d %>%
gather(responseTo, rating, responseCC:responseMC) %>%
mutate(responseTo = recode(responseTo, "responseCC" = "CC", "responseMC" = "BEL")) %>%
mutate(qud = recode(qud, "ai" = "CC?", "nai" = "BEL?"))
nrow(d) #654
# because rating assumes values of 0 and 1, which beta regression cannot handle, transform: (Smithson & Verkuilen 2006)
# y_new = (y_old * (n−1) + 0.5) / n (where n is the sample size)
# note: first rescaling of y'=(y-a)/(b-a) not necessary because highest and lowest value are 0 and 1 already
summary(d$rating)
d$betarating = (d$rating*(nrow(d)-1) + .5)/nrow(d)
summary(d$betarating)
# filter to relevant utterances and set reference levels
proj = d %>%
filter(utterance == "know-neg" | utterance == "think-neg") %>%
filter(responseTo == "BEL") %>%
mutate(qud = fct_relevel(qud, "CC?"),
utterance = fct_relevel(utterance, "think-neg"))
nrow(proj)
# fit the model
prior = get_prior(betarating ~ utterance*qud + (1|content),family = Beta(),data=proj)
prior
betamodel = bf(betarating ~ utterance*qud + (1|content),
phi ~ utterance+qud, # beta distribution's precision
family = Beta())
m.b = brm(formula = betamodel,
family=Beta(),
data=proj,
cores = 4, iter = 8000, warmup = 1000,
control = list(adapt_delta = .9999999,max_treedepth=20))
# model summary
summary(m.b)
# save the model
saveRDS(m.b,file="../models/projection-of-BEL-in-neg-know-and-neg-think.rds")
# read the model
m.b <- readRDS(file="../models/projection-of-BEL-in-neg-know-and-neg-think.rds")
m.b
# run posterior predictive checks
p1 <- pp_check(m.b, type = "dens_overlay_grouped", group = "utterance", ndraws = 100) +
scale_x_continuous(breaks = seq(0,1,by=.25))
p1
m.b
# save the model
saveRDS(m.b,file="../models/projection-of-BEL-in-neg-know-and-neg-think-CCqud.rds")
# save the model
saveRDS(m.b,file="../models/projection-of-BEL-in-neg-know-and-neg-think-CCqud.rds")
# read the model
m.b <- readRDS(file="../models/projection-of-BEL-in-neg-know-and-neg-think-CCqud.rds")
m.b
# run posterior predictive checks
p1 <- pp_check(m.b, type = "dens_overlay_grouped", group = "utterance", ndraws = 100) +
scale_x_continuous(breaks = seq(0,1,by=.25))
p1
#estimate
hypothesis(m.b,"utteranceknowMneg > 0")$hypothesis$Estimate #0.4250258
# posterior probability
hypothesis(m.b,"utteranceknowMneg > 0")$hypothesis$Post.Prob #0.7296071
# Bayes factor
hypothesis(m.b,"utteranceknowMneg > 0")$hypothesis$Evid.Ratio #2.698323
# load data
d = read_csv("../data/cd.csv")
nrow(d) #327
# transform the data
d = d %>%
gather(responseTo, rating, responseCC:responseMC) %>%
mutate(responseTo = recode(responseTo, "responseCC" = "CC", "responseMC" = "BEL")) %>%
mutate(qud = recode(qud, "ai" = "CC?", "nai" = "BEL?"))
nrow(d) #654
# because rating assumes values of 0 and 1, which beta regression cannot handle, transform: (Smithson & Verkuilen 2006)
# y_new = (y_old * (n−1) + 0.5) / n (where n is the sample size)
# note: first rescaling of y'=(y-a)/(b-a) not necessary because highest and lowest value are 0 and 1 already
summary(d$rating)
d$betarating = (d$rating*(nrow(d)-1) + .5)/nrow(d)
summary(d$betarating)
# filter to relevant utterances and set reference levels
proj = d %>%
filter(utterance == "know-neg" | utterance == "think-neg") %>%
filter(responseTo == "BEL") %>%
mutate(qud = fct_relevel(qud, "BEL?"),
utterance = fct_relevel(utterance, "think-neg"))
nrow(proj)
# fit the model
prior = get_prior(betarating ~ utterance*qud + (1|content),family = Beta(),data=proj)
prior
betamodel = bf(betarating ~ utterance*qud + (1|content),
phi ~ utterance+qud, # beta distribution's precision
family = Beta())
m.b = brm(formula = betamodel,
family=Beta(),
data=proj,
cores = 4, iter = 8000, warmup = 1000,
control = list(adapt_delta = .9999999,max_treedepth=20))
# model summary
summary(m.b)
# save the model
saveRDS(m.b,file="../models/projection-of-BEL-in-neg-know-and-neg-think-BELqud.rds")
# read the model
m.b <- readRDS(file="../models/projection-of-BEL-in-neg-know-and-neg-think-BELqud.rds")
m.b
# run posterior predictive checks
p1 <- pp_check(m.b, type = "dens_overlay_grouped", group = "utterance", ndraws = 100) +
scale_x_continuous(breaks = seq(0,1,by=.25))
p1
#estimate
hypothesis(m.b,"utteranceknowMneg > 0")$hypothesis$Estimate #1.3
# posterior probability
hypothesis(m.b,"utteranceknowMneg > 0")$hypothesis$Post.Prob #1
# Bayes factor
hypothesis(m.b,"utteranceknowMneg > 0")$hypothesis$Evid.Ratio #Inf
# Bayes factor
hypothesis(m.b,"utteranceknowMneg > 0")$hypothesis$Evid.Ratio #3.9
# load datas
d = read_csv("../data/cd.csv")
nrow(d) #327
# transform the data
d = d %>%
gather(responseTo, rating, responseCC:responseMC) %>%
mutate(responseTo = recode(responseTo, "responseCC" = "CC", "responseMC" = "BEL")) %>%
mutate(qud = recode(qud, "ai" = "CC?", "nai" = "BEL?"))
nrow(d) #654
# because rating assumes values of 0 and 1, which beta regression cannot handle, transform: (Smithson & Verkuilen 2006)
# y_new = (y_old * (n−1) + 0.5) / n (where n is the sample size)
# note: first rescaling of y'=(y-a)/(b-a) not necessary because highest and lowest value are 0 and 1 already
summary(d$rating)
d$betarating = (d$rating*(nrow(d)-1) + .5)/nrow(d)
summary(d$betarating)
# filter to relevant utterance and set reference levels
proj = d %>%
filter(utterance == "know-neg") %>%
mutate(qud = fct_relevel(qud, "CC?"),
responseTo = fct_relevel(responseTo, "CC"))
nrow(proj) #152
# fit the model
prior = get_prior(betarating ~ responseTo*qud + (1|content),family = Beta(),data=proj)
prior
# fit the model
prior = get_prior(betarating ~ responseTo*qud + (1|content),family = Beta(),data=proj)
prior
betamodel = bf(betarating ~ responseTo*qud + (1|content),
phi ~ responseTo+qud, # beta distribution's precision
family = Beta())
m.b = brm(formula = betamodel,
family=Beta(),
data=proj,
cores = 4, iter = 8000, warmup = 1000,
control = list(adapt_delta = .9999999,max_treedepth=20))
# model summary
summary(m.b)
# save the model
saveRDS(m.b,file="../models/projection-of-CC-and-BEL-in-neg-know.rds")
# read the model
m.b <- readRDS(file="../models/projection-of-CC-and-BEL-in-neg-know.rds")
m.b
# run posterior predictive checks
p1 <- pp_check(m.b, type = "dens_overlay_grouped", group = "utterance", ndraws = 100) +
scale_x_continuous(breaks = seq(0,1,by=.25))
# run posterior predictive checks
p1 <- pp_check(m.b, type = "dens_overlay_grouped", group = "responseTo", ndraws = 100) +
scale_x_continuous(breaks = seq(0,1,by=.25))
p1
# pairwise comparison for each predictor while holding the other one constant
pairs(emmeans(m.b, ~ responseTo*qud), simple = "each")
# pairwise comparison for each predictor while holding the other one constant
pairs(emmeans(m.b, ~ responseTo*qud), simple = "each")
