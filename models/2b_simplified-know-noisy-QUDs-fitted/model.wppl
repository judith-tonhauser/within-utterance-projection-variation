// helper functions
var stringify = function(x){return JSON.stringify(x)}

// utterances
var utterances = ["pos-know-pos-dance", 
                  "pos-think-pos-dance",
                  "neg-know-pos-dance", 
                  "neg-think-pos-dance",
                  "pos-bare-pos-dance",
                  "neg-bare-pos-dance"
                  ]


// utterance prior is uniform
var utterancePrior = function() {
  uniformDraw(utterances)
}

// cost: simple utterance is less costly than complex utterance
var cost = function(utterance) {
  var splitutt = utterance.split('-')
  var predicate = splitutt[1]
  return predicate == "bare" ? 1 : 1.15 
}

// world states
// BEL: Does the attitude holder believe that the CC is true? 1:yes / 0:no
// CC: Is the CC true? 1:yes / 0:no
var worldState = [
  {BEL: 1, CC: 1}, 
  {BEL: 1, CC: 0}, 
  {BEL: 0, CC: 1},
  {BEL: 0, CC: 0}
]

var statePrior = function(qudBias) {
  var BELval = flip(0.75) ? 1 : 0// BEL baserate
  var CCval = flip(0.75) ? 1 : 0// CC baserate
  return {BEL: BELval, CC: CCval}
//   return categorical({vs: worldState,ps: [1,1,1,0.5]}) // bias against {0,0} state
}


// qudPriorLookup returns qud based on qudBias
// assume that cues to QUD CC? weren't sufficiently strong
// var qudPriorLookup = function(qudBias) {
// //     qudBias == "BEL?" ? "mcQUD" : "ccQUD"
// // }
var qudPriorLookup = function(qudBias) {
    qudBias == "BEL?" ? categorical({
    vs: ["ccQUD", "mcQUD"], ps: [1, 100]
  }) : categorical({
    vs: ["ccQUD", "mcQUD"], ps: [1, 2]
  })
}

// non-uniform state prior for Pragmatic Listener, based on CCprior ("higher" or "lower")
// var statePrior = function(CCprior) {
//   return CCprior == "higher" ? categorical({
//     vs: worldState,
//     ps: [2,1,2,1]}) : categorical({
//     vs: worldState,
//     ps: [1,2,1,2]})
  
// }

// what the speaker privately believes ("Common ground" in Qing et al 2016)
var commonGround = [
  // no beliefs
  worldState,
  // speaker observes dancing = 1 or dancing = 0
  [{BEL: 1, CC: 1}, {BEL: 0, CC: 1}],
  [{BEL: 1, CC: 0}, {BEL: 0, CC: 0}],
  // speaker observes bel = 1 or bel = 0
  [{BEL: 1, CC: 1}, {BEL: 1, CC: 0}],
  [{BEL: 0, CC: 1}, {BEL: 0, CC: 0}],
  // speaker has full belief about both parts
//   [{BEL: 1, CC: 1}], 
//   [{BEL: 1, CC: 0}],
//   [{BEL: 0, CC: 1}],
//   [{BEL: 0, CC: 0}]
]

var CGPrior = function() {
  return categorical({
    vs: commonGround,
    ps: [4, 2, 2, 2, 2] //, 1, 1, 1, 1]
  })
}


// QUDs
var qudFns = {
  maxQUD : function(state) {return {BEL: state.BEL, CC: state.CC}},
  ccQUD : function(state) {return {CC: state.CC}},
  mcQUD : function(state) {return {BEL: state.BEL}}
}


// uniform prior over QUDs
// var qudPrior = function() {
//   categorical({
//     vs: ["ccQUD", "mcQUD"], ps: [1, 1]
//   })
// }

// Speaker optimality parameter
var alpha = 10

// meaning function
var meaning = function(utterance, state) {
    utterance == "pos-know-pos-dance" ? state.BEL == 1 && state.CC == 1 :
    utterance == "pos-think-pos-dance" ? state.BEL == 1 :
    utterance == "pos-bare-pos-dance" ? state.CC == 1 :
    // negated versions
    utterance == "neg-know-pos-dance" ? false == (state.BEL == 1 && state.CC == 1) :
    utterance == "neg-think-pos-dance" ? false == (state.BEL == 1) :
    utterance == "neg-bare-pos-dance" ? false == (state.CC == 1) : true
  }

//  literal listener
var literalListener = function(utterance, cg, qud) {
  Infer({model: function() {
    var state = uniformDraw(worldState)
    var qudFn = qudFns[qud]
    var qudAnswer = qudFn(state)
    // LL requires the sampled state to be consisted with the cg passed down from the speaker
    var stringCG = stringify(cg)
    var stringState = stringify(state)
    condition(stringCG.includes(stringState))
    condition(meaning(utterance, state))
    return qudAnswer
  }})
} 

// speaker
var speaker = function(state, cg, qud) {
  Infer({model: function() {
    var utterance = uniformDraw(utterances)
    var qudFn = qudFns[qud]
    var qudAnswer = qudFn(state)
    condition(meaning(utterance, state)) // the speaker is always truthful
    factor(alpha *
           (literalListener(utterance, cg, qud).score(qudAnswer)
          - cost(utterance)))
    return utterance
  }})
}

// pragmatic listener
var pragmaticListener = function(utterance, qudBias) {
  Infer({model: function() {
    var state = statePrior()
    var cg = CGPrior()
    var qud = qudPriorLookup(qudBias)
    // the sampled state is consistent with the speaker's beliefs
    var stringCG = stringify(cg)
    var stringState = stringify(state)
    condition(stringCG.includes(stringState))
    observe(speaker(state, cg, qud), utterance)
    // return {BEL: state.BEL, CC: state.CC, qud: qud}
    // return state.BEL
    return {BEL: state.BEL, CC: state.CC}
//     return {state: state, cg: cg}
//     return {state:state, qud:qud}
  }})
}

// define some speaker beliefs for easier reference
var ccTrue = [{BEL: 0, CC: 1},{BEL: 1, CC: 1}]
var ccFalse = [{BEL: 0, CC: 0},{BEL: 1, CC: 0}]
var belTrue = [{BEL: 1, CC: 0},{BEL: 1, CC: 1}]
var belFalse = [{BEL: 0, CC: 0},{BEL: 0, CC: 1}]
var falseFalse = [{BEL: 0, CC: 0}]
var trueFalse = [{BEL: 0, CC: 0}]
var falseTrue = [{BEL: 0, CC: 1}]
var trueTrue = [{BEL: 1, CC: 1}]

// //TARGET
// //BEL?: .247 [0.172, 0.324] BEL, 0.73 [0.649, 0.806] CC
// //CC?:  .341 [0.262, 0.415] BEL, 0.62 [0.541, 0.707] CC

// // // display("PL interprets _Cole doesn't know that Julian dances salsa_ with QUD mc?:")
// print("BEL?")
// viz.table(pragmaticListener("neg-know-pos-dance","BEL?"))

// // // display("PL interprets _Cole doesn't know that Julian dances salsa_ with QUD mc?:")
// print("CC?")
// viz.table(pragmaticListener("neg-know-pos-dance","CC?"))


// viz.table(Infer(statePrior))
